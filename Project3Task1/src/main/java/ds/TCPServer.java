/**
 * The class is a Java implementation of a TCP server that
 * interacts with a blockchain. The server communicates
 * with clients using JSON messages over the network. The server
 * performs various blockchain-related tasks, such as adding blocks,
 * verifying the blockchain, and repairing the chain.
 * The server's main method contains an infinite loop that listens for
 * incoming connections and processes them as needed.
 *  * @author: Ruta Deshpande
 *  * @andrew id: rutasurd
 *  * @email id: rutasurd@andrew.cmu.edu
 *  * @date: 16th March 2023
 *  * Project 3
 */
package ds;
//imports
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;

import java.io.BufferedWriter;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.math.BigInteger;
import java.net.ServerSocket;
import java.net.Socket;
import java.sql.Timestamp;
import java.util.Scanner;

public class TCPServer {
    static Scanner in;
    static PrintWriter out;
    public static void main(String args[]) {
        Socket clientSocket = null;
        try {
            //defining variables
            int selection,difficulty,corruptId;
            String data;
            double elapsedTime;
            int serverPort = 7777; // defining the server port we are using

            // Create a new server socket
            ServerSocket listenSocket = new ServerSocket(serverPort);
            clientSocket = listenSocket.accept();
            // Set up "in" to read from the client socket
            in = new Scanner(clientSocket.getInputStream());
            // Set up "out" to write to the client socket
            out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(clientSocket.getOutputStream())));

            System.out.println("Blockchain server is running");
            System.out.println("We have a visitor");
            //creating new blockchain object
            BlockChain blockchain = new BlockChain();
            //calling the computeHashesPerSecond method
            blockchain.computeHashesPerSecond();
            //creating a genesis block
            Block genesis = new Block(0, blockchain.getTime(), "Genesis", 2);
            //set previous hash of genesis as blank
            genesis.setPreviousHash("");
            //compute the proof of work for genesis block
            genesis.proofOfWork();
            //add genesis block to blockchain
            blockchain.addBlock(genesis);
            while (true) {
                //getting line of data from client
                String messageFromClient = in.nextLine();
                //converting data from client into json objet
                JsonObject jsonObject = new JsonParser().parse(messageFromClient).getAsJsonObject();
                //get the selection member
                selection = jsonObject.get("selection").getAsInt();
                //defining variables for use further
                ResponseMessage responseMessage;
                Timestamp startTime,endTime;
                switch(selection)
                {
                    //case of displaying basic parameters of chain
                    case 0:
                        // get the current size of the blockchain
                        int chainSize = blockchain.getChainSize();
                        // get the difficulty of the latest block in the blockchain
                        int chainDifficulty = blockchain.getLastestBlock().getDifficulty();
                        // get the total difficulty of the blockchain
                        int chainTotalDifficulty = blockchain.getTotalDifficulty();
                        // get the number of hashes per second being generated by the blockchain
                        int chainHashesPerSecond = blockchain.getHashesPerSecond();
                        // get the expected number of hashes for the entire blockchain
                        double chainExpectedHashes = blockchain.getTotalExpectedHashes();
                        // get the nonce of the latest block in the blockchain
                        BigInteger chainNonce = blockchain.getLatestBlock().getNonce();
                        // Calculates the hash of the latest block in the blockchain
                        String chainHash = blockchain.getLatestBlock().calculateHash();
                        // Creates a response message object containing the blockchain data
                        responseMessage = new ResponseMessage(selection, chainSize, chainDifficulty, chainTotalDifficulty, chainHashesPerSecond, chainExpectedHashes, chainNonce, chainHash);
                        // Sends the response message to the client
                        sendToClient(responseMessage.toString());
                        System.out.println("Response:\n"+responseMessage.toString());
                        break;


                    case 1:
                        System.out.println("Adding a block");
                        difficulty =  jsonObject.get("difficulty").getAsInt();
                        data = jsonObject.get("data").getAsString();
                        startTime = blockchain.getTime();
                        //Create new block and set appropriate properties / complete proof of work
                        Block newBlock = new Block(blockchain.getChainSize(), blockchain.getTime(), data, difficulty);
                        //setting previous hash as chainhash
                        newBlock.setPreviousHash(blockchain.chainHash);
                        //calculate proof of work for new block
                        newBlock.proofOfWork();
                        //add block to blockchain
                        blockchain.addBlock(newBlock);
                        //Compute elapsed time
                        endTime = blockchain.getTime();
                        //calculating elapsedTime
                        elapsedTime = endTime.getTime() - startTime.getTime();
                        System.out.println("Setting response to Total execution time to add this block was "+elapsedTime+" milliseconds");
                        //creating responsemessage obj using selection and elapsedtime as parameters
                        responseMessage = new ResponseMessage(selection,elapsedTime);
                        //sending the json obj to client
                        sendToClient(responseMessage.toString());
                        String res = "Total execution time to add this block was "+elapsedTime+" milliseconds";
                        JsonObject jsonObj = new JsonObject();
                        jsonObj.addProperty("selection",selection);
                        jsonObj.addProperty("response",res);
                        System.out.println("..."+jsonObj.toString());
                        break;

                    case 2:
                        System.out.println("Verifying entire chain");
                        //getting startime
                        startTime = blockchain.getTime();
                        //checking if chain is valid
                        System.out.println(blockchain.isChainValid());
                        //getting end time
                        endTime = blockchain.getTime();
                        //getting elapsed time
                        elapsedTime = endTime.getTime() - startTime.getTime();
                        //creating responsemessage obj using selection and elapsedtime as parameters
                        responseMessage = new ResponseMessage(selection,elapsedTime);
                        //setting response in responseMessage obj
                        responseMessage.setResponse(blockchain.isChainValid());
                        System.out.println("Setting response to Total execution time to verify the chain was "+elapsedTime+" milliseconds");
                        System.out.println("Total execution time to verify the chain was "+elapsedTime+" milliseconds");
                        //sending the response to client as json
                        sendToClient(responseMessage.toString());
                        break;

                    case 3:
                        System.out.println("View the blockchain");
                        //creating responsemessage obj using selection as parameters
                        responseMessage = new ResponseMessage(selection);
                        //setting response in responseMessage obj
                        responseMessage.setResponse(blockchain.toString());
                        System.out.println("Setting response to"+blockchain.toString());
                        //sending the response to client as json
                        sendToClient(responseMessage.toString());
                        break;

                    case 4:
                        System.out.println("Corrupt the Blockchain");
                        //extracting data from json
                        data = jsonObject.get("data").getAsString();
                        //extracting corruptid from json obj
                        corruptId = jsonObject.get("corruptId").getAsInt();
                        //setting the new data on the block
                        blockchain.getBlock(corruptId).setData(data);
                        System.out.printf("Block %d now holds %s\n",corruptId,data);
                        System.out.print("Setting response to Block " +corruptId+ " now holds " +data+"\n");
                        //creating new responsemessage object
                        responseMessage = new ResponseMessage(selection);
                        //setting response in responseMessage obj
                        responseMessage.setResponse("Block " +corruptId+ " now holds " +data);
                        //sending the response to client as json
                        sendToClient(responseMessage.toString());
                        break;

                    case 5:
                        System.out.println("Repairing the entire chain");
                        //getting starttime
                        startTime = blockchain.getTime();
                        //calling the repair function on blockchain
                        blockchain.repairChain();
                        //getting endtime
                        endTime = blockchain.getTime();
                        //calculating elapsed time
                        elapsedTime = endTime.getTime() - startTime.getTime();
                        System.out.println("Setting response to Total execution time to repair the chain was "+elapsedTime+" milliseconds");
                        //creating a new responsemessage object with selectiona nd elapsedtime as parameters
                        responseMessage = new ResponseMessage(selection,elapsedTime);
                        res = "Total execution time to repair the chain was "+elapsedTime+" milliseconds";
                        //setting response in responseMessage obj
                        responseMessage.setResponse(res);
                        //sending the response to client as json
                        sendToClient(responseMessage.toString());
                        break;

                    case 6:
                        System.out.println("Quitting!");

                }

            }

            // Handle exceptions
        } catch (IOException e) {
            System.out.println("IO Exception:" + e.getMessage());

            // If quitting (typically by you sending quit signal) clean up sockets
        } finally {
            try {
                if (clientSocket != null) {
                    clientSocket.close();
                }
            } catch (IOException e) {
                // ignore exception on close
            }
        }
    }
    //method for sending data to client
    public static void sendToClient(String result)
    {
        out.println(result);
        out.flush();
    }
}